3. advance(n) for random access ranges? but how to detect if advance with
   negative N is safe?
    Obviously, this can be safe if absolute value of N is < size();
    From this, ranges with random access order should be either endless or
    limited.
5. Force random access ranges to be endless or limited
6. Force solid ranges to be limited random access ranges
7. Is there one_pass double ended ranges possible?
8. Forbid one pass random access ranges?
9. Prev for double ended ranges?
10. For solid ranges, operator [] should be implemented by default as *(&front() + n)
11. Assert in rangeâ€¦.hpp
12. Forbid solid endless ranges

---1. swap() for swappable---
---2. size() for forward unlimited ranges, what is the size_type should be in this case?---
---4. Remove inheritance from unlimited to endless ranges---
